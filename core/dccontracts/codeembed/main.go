package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/ethereum/go-ethereum/common"
)

func main() {
	var (
		input   = flag.String("input", "", "input file")
		outfile = flag.String("output", "", "output file")
		name    = flag.String("name", "", "name of the contract")
	)
	flag.Parse()

	if info, err := os.Stat(*input); info == nil || err != nil {
		fatal("File not exists")
	}

	if *name == "" {
		fatal("Name is required")
	}

	if *outfile == "" {
		fatal("Output is required")
	}

	// output bytecode hex file to hex folder
	hexOutputDir := filepath.Join(
		filepath.Dir(*outfile), "hex")
	os.MkdirAll(hexOutputDir, 0755)

	hexFileName := filepath.Base(
		fmt.Sprintf("%s.hex", strings.TrimSuffix(*outfile, filepath.Ext(*outfile))))
	goFileName := strings.ToLower(
		fmt.Sprintf("%s.go", strings.TrimSuffix(*outfile, filepath.Ext(*outfile))))

	bytecodeStr, err := os.ReadFile(*input)
	if err != nil {
		fatal(err)
	}

	bytecode := common.FromHex(strings.TrimSpace(string(bytecodeStr)))
	if err := os.WriteFile(filepath.Join(hexOutputDir, hexFileName), bytecode, 0644); err != nil {
		fatal(err)
	}

	code := generateByteCode(*name, hexFileName, sha256sum(bytecodeStr), sha256sum(bytecode))

	// create bytecode file
	var header bytes.Buffer
	fmt.Fprint(&header, "// Code generated by codeembed. DO NOT EDIT.\n\n")

	if err := os.WriteFile(goFileName, append(header.Bytes(), code...), 0644); err != nil {
		fatal(err)
	}
}

func fatal(args ...interface{}) {
	fmt.Fprintln(os.Stderr, args...)
	os.Exit(1)
}

func sha256sum(data []byte) string {
	shasum := sha256.Sum256(data)
	return hex.EncodeToString(shasum[:])
}

func generateByteCode(name, output, bytecodeSha256, hexSha256 string) []byte {
	var code bytes.Buffer
	fmt.Fprintf(&code, "package dccontracts\n\n")
	fmt.Fprintf(&code, "import (\n")
	fmt.Fprintf(&code, "\t_ \"embed\"\n")
	fmt.Fprintf(&code, ")\n\n")
	fmt.Fprintf(&code, "// ByteCodeSha256: %s\n", bytecodeSha256)
	fmt.Fprintf(&code, "// HexByteCodeSha256: %s\n", hexSha256)
	fmt.Fprintf(&code, "//go:embed hex/%s\n", output)
	fmt.Fprintf(&code, "var %s []byte\n", name)
	return code.Bytes()
}
